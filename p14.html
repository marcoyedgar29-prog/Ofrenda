<!doctype html>
<html lang="es">
<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>Ofrenda Día de Muertos - Pixel Art</title>
	<style>
		:root{
			--bg:#0b0220;
		}
		html,body{height:100%;margin:0;background:var(--bg);font-family:system-ui,Segoe UI,Roboto;}
		.container{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:18px;gap:12px;color:#fff;text-align:center;}
		.canvas-wrap{background:linear-gradient(180deg, rgba(0,0,0,.25), rgba(0,0,0,.5));padding:14px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,.6); position:relative; overflow:hidden;}
		canvas{display:block;background:transparent;image-rendering:pixelated;border:6px solid rgba(255,255,255,.06);border-radius:6px;}
		.controls{display:flex;gap:8px;align-items:center;justify-content:center;}
		label{font-size:13px;opacity:.9}
		input[type="range"]{width:220px;}
		.credit{font-size:12px;opacity:.8}
	</style>
	<!-- cargar CSS externo después del bloque <style> para asegurar que sus reglas se apliquen -->
	<link rel="stylesheet" href="./decoracion.css">
</head>
<body>
	<div class="container">
		<h1>Ofrenda - Pixel Art</h1>
		<div class="canvas-wrap">
			<canvas id="pxc"></canvas>
			<!-- overlay para confetti/partículas y decoraciones CSS -->
			<div class="decor-overlay" id="decor" aria-hidden="true"></div>
		</div>
		<div class="controls">
			<label for="scale">Escala</label>
			<input id="scale" type="range" min="4" max="14" value="8">
			<button id="redraw">Redibujar</button>
		</div>
		<div class="credit">Colorida ofrenda pixel art con calavera, velas, flores y papel picado</div>
	</div>

	<script>
		// Configuración del "lienzo lógico" (pixel art)
		const W = 120, H = 90; // resolución lógica ampliada para más elementos
		const canvas = document.getElementById('pxc');
		const ctx = canvas.getContext('2d');
		canvas.width = W;
		canvas.height = H;
		ctx.imageSmoothingEnabled = false;

		const palette = {
			bg1: "#1b0233", bg2: "#2b0b5b",
			papel1: "#ff2d95", papel2: "#ffd23f", papel3: "#33d6ff",
			altar: "#6a3b18", altar2: "#c96e1a",
			marigold1: "#ff9d00", marigold2: "#ffd400",
			candle: "#fff9cc", flame1: "#ffd23f", flame2: "#ff6b00",
			skull: "#ffffff", skullDec: "#d44c9c", eye: "#0b3d6b",
			bread: "#8c4b2f", breadDec:"#d99f73",
			fruit1:"#ff3864", fruit2:"#4cd97b", fruit3:"#ff8c1a",
			leaf:"#2f8b3e", dark:"#000000"
		};

		// Funciones helper
		function setPixel(x,y,color){ ctx.fillStyle = color; ctx.fillRect(x,y,1,1); }
		function rect(x,y,w,h,color){ ctx.fillStyle=color; ctx.fillRect(x,y,w,h); }
		function circle(cx,cy,r,color){
			ctx.fillStyle = color;
			for(let y=Math.floor(cy-r); y<=Math.ceil(cy+r); y++){
				for(let x=Math.floor(cx-r); x<=Math.ceil(cx+r); x++){
					if((x-cx)*(x-cx)+(y-cy)*(y-cy) <= r*r) ctx.fillRect(x,y,1,1);
				}
			}
		}
		function hline(x,y,w,color){ rect(x,y,w,1,color); }
		function vline(x,y,h,color){ rect(x,y,1,h,color); }

		// Dibujar fondo degradado nocturno
		function drawBackground(){
			for(let y=0;y<H;y++){
				const t = y / (H-1);
				// Mezcla simple entre bg1 y bg2 con toque oscuro
				const c = lerpColor(palette.bg1, palette.bg2, t);
				hline(0,y,W,c);
			}
		}

		// Mezcla de colores hex (simple)
		function lerpColor(a,b,t){
			const pa = hexToRgb(a), pb = hexToRgb(b);
			const r = Math.round(pa.r + (pb.r-pa.r)*t);
			const g = Math.round(pa.g + (pb.g-pa.g)*t);
			const bl = Math.round(pa.b + (pb.b-pa.b)*t);
			return `rgb(${r},${g},${bl})`;
		}
		function hexToRgb(hex){
			hex = hex.replace('#','');
			if(hex.length===3) hex = hex.split('').map(c=>c+c).join('');
			return {r:parseInt(hex.slice(0,2),16), g:parseInt(hex.slice(2,4),16), b:parseInt(hex.slice(4,6),16)};
		}

		// Papel picado en la parte superior (con variedad de formas)
		function drawPapelPicado(){
			const top = 4;
			const shapes = ['diamond','star','scallop','triangle','cross'];
			for(let i=0;i<8;i++){
				const x = 4 + i*9;
				const color = (i%3===0)?palette.papel1: (i%3===1)?palette.papel2:palette.papel3;
				rect(x,top,8,6,color);
				// seleccionar tipo de corte según índice para variar las formas
				const shape = shapes[i % shapes.length];

				// helpers locales para dibujar relativo al rectángulo
				const px = (ox, oy) => setPixel(x + ox, top + oy, palette.dark);
				const hpx = (ox, oy, w) => hline(x + ox, top + oy, w, palette.dark);

				if(shape === 'diamond'){
					// diamante central
					px(3,0); px(4,0);
					px(2,1); px(5,1);
					px(1,2); px(6,2);
					px(3,2); px(4,2);
					px(2,3); px(5,3);
				} else if(shape === 'star'){
					// cruz con diagonales
					px(3,1); px(4,1);
					px(2,2); px(5,2);
					px(3,2); px(4,2);
					px(1,3); px(6,3);
					px(3,3); px(4,3);
				} else if(shape === 'scallop'){
					// ondas / semicírculos en borde inferior
					px(1,3); px(2,4); px(3,4);
					px(4,4); px(5,4); px(6,3);
					// pequeñas perforaciones superiores
					px(3,1); px(4,1);
				} else if(shape === 'triangle'){
					// triángulo invertido central
					px(3,1);
					hpx(2,2,4);
					hpx(1,3,6);
				} else if(shape === 'cross'){
					// pequeñas cruces y puntos
					px(2,1); px(5,1);
					px(3,2); px(4,2);
					px(2,3); px(5,3);
					px(3,4); px(4,4);
				}
				// pequeños detalles adicionales para variedad
				if(i % 2 === 0){
					// añadir un punto en esquina superior interna ocasionalmente
					setPixel(x+1, top+1, palette.dark);
				}
			}
		}

		// Niveles del altar (3 niveles)
		function drawAltar(){
			// nivel inferior (más ancho)
			rect(4, 54, 112, 10, palette.altar);
			hline(4,53,112,palette.altar2);
			// nivel medio-bajo
			rect(14,44,92,8,palette.altar2);
			hline(14,43,92,palette.altar);
			// nivel medio-alto
			rect(28,36,64,6,palette.altar);
			hline(28,35,64,palette.altar2);
			// nivel superior
			rect(40,28,40,5,palette.altar2);
			hline(40,27,40,palette.altar);
			// suelo / sombra
			for(let i=0;i<10;i++) hline(0,64+i,W,`rgba(0,0,0,${0.02*i})`);
		}

		// Marigolds (flores) como pequeñas manchas naranjas alrededor
		function drawMarigolds(){
			const clusters = [
				[10,41],[16,39],[24,38],[36,37],[46,37],[55,37],[64,39]
			];
			clusters.forEach(([x,y])=>{
				for(let dx=-2;dx<=2;dx++){
					for(let dy=-2;dy<=2;dy++){
						if(Math.abs(dx)+Math.abs(dy) <=2){
							const c = (Math.random()<0.6)?palette.marigold1:palette.marigold2;
							setPixel(x+dx,y+dy,c);
						}
					}
				}
			});
		}

		// Velas (modificada para fuego con pequeña variación por render)
		function drawCandles(){
			const candleXs = [18,32,40,48,62];
			candleXs.forEach(x=>{
				// base de vela
				for(let h=0; h<5; h++) setPixel(x, 23+h, palette.candle);
				// mecha
				setPixel(x,22,palette.dark);
				// fuego con pequeña variación aleatoria para simular parpadeo
				const flick = Math.random() < 0.5;
				const flameOffsetY = flick ? 20 : 19;
				const flameCol = (Math.random()<0.4)?palette.flame2:palette.flame1;
				setPixel(x,flameOffsetY,flameCol);
				setPixel(x,flameOffsetY-1,palette.flame1);
				if(Math.random()<0.6) setPixel(x-1,flameOffsetY,palette.flame1);
				if(Math.random()<0.6) setPixel(x+1,flameOffsetY,palette.flame1);
			});
		}

		// Calavera central (pixel circle) con decoraciones
		function drawSkull(){
			const cx = 40, cy = 18, r = 7;
			circle(cx,cy,r,palette.skull);
			// ojos
			circle(cx-3,cy-1,2,palette.eye);
			circle(cx+3,cy-1,2,palette.eye);
			// nariz y boca
			setPixel(cx,cy+1,palette.dark);
			hline(cx-3,cy+3,7,palette.dark);
			// decoraciones
			for(let i=0;i<6;i++){
				const a = Math.PI*(i/3);
				const sx = cx + Math.round(Math.cos(a)*(r+1.2));
				const sy = cy + Math.round(Math.sin(a)*(r+1.0));
				setPixel(sx,sy,palette.skullDec);
			}
		}

		// Pan de muerto y frutas
		function drawOfferings(){
			// pan (a la izquierda)
			circle(30,33,3,palette.bread);
			setPixel(30,33,palette.breadDec);
			// frutas (derecha)
			circle(50,34,2,palette.fruit1);
			circle(55,34,2,palette.fruit2);
			circle(60,34,2,palette.fruit3);
			// hojas minimalistas
			setPixel(54,31,palette.leaf);
			setPixel(58,31,palette.leaf);
		}

		// Pequeños adornos y sombras
		function drawDetails(){
			// brillos sobre altar
			for(let x=12;x<70;x+=6){
				setPixel(x,32,palette.altar2);
				setPixel(x+1,32,palette.altar2);
			}
			// pequeñas velas en primer plano (sobre nivel medio)
			setPixel(22,31,palette.candle);
			setPixel(36,29,palette.candle);
			setPixel(52,31,palette.candle);
		}

		// Función nueva: dibuja una calaverita pequeña (mini)
		function drawMiniSkull(cx,cy){
			const r = 3;
			// cráneo
			circle(cx,cy,r,palette.skull);
			// ojos pequeños
			circle(cx-1,cy-1,1,palette.eye);
			circle(cx+1,cy-1,1,palette.eye);
			// nariz y boca simplificada
			setPixel(cx,cy+1,palette.dark);
			hline(cx-2,cy+2,5,palette.dark);
			// pequeñas decoraciones
			setPixel(cx-2,cy-2,palette.skullDec);
			setPixel(cx+2,cy-2,palette.skullDec);
		}

		// Función nueva: coloca varias calaveritas pequeñas alrededor del altar
		function drawMoreSkulls(){
			const coords = [
				[10,36], [18,35], [26,34], // lado izquierdo del altar
				[52,34], [60,36], [68,36]  // lado derecho del altar
			];
			coords.forEach(([x,y]) => drawMiniSkull(x,y));
			// algunas en el nivel superior del altar
			drawMiniSkull(34,26);
			drawMiniSkull(46,26);
		}

		// --- Nuevo: fotos enmarcadas sobre el altar (pequeñas "polaroids") ---
		function drawPhotos(){
			const frames = [
				{ x: 46, y: 22, color: '#fff6d8' },
				{ x: 66, y: 22, color: '#fff6d8' },
				{ x: 56, y: 22, color: '#fff6d8' }
			];
			frames.forEach((f, idx) => {
				// marco
				rect(f.x-2, f.y-2, 8, 10, '#111'); // sombra
				rect(f.x-1, f.y-1, 8, 8, f.color);
				// "foto" simple (pixel portrait)
				const base = (idx%2===0)? palette.papel3 : palette.papel1;
				rect(f.x, f.y, 6, 4, base);
				setPixel(f.x+2, f.y+1, palette.skullDec); // cara/simple detalle
				setPixel(f.x+3, f.y+1, palette.dark);
				// nombre/etiqueta abajo
				hline(f.x, f.y+4, 6, '#f0e6c8');
				setPixel(f.x+1, f.y+4, palette.dark);
			});
		}

		// --- Nuevo: comida y platos ---
		function drawFood(){
			// bandeja izquierda: pan + tamales
			circle(20, 58, 4, '#f7e3c2'); // plato
			for(let dx=-2; dx<=2; dx++){
				setPixel(20+dx,58, palette.bread); // panes
			}
			// centro: platos con frutas
			circle(60, 50, 5, '#eae9f5'); // plato blanco
			for(let i=0;i<6;i++){
				const ang = i * (Math.PI*2/6);
				const rx = 60 + Math.round(Math.cos(ang)*3);
				const ry = 50 + Math.round(Math.sin(ang)*2);
				setPixel(rx, ry, [palette.fruit1,palette.fruit2,palette.fruit3][i%3]);
			}
			// derecha: botella y vaso
			rect(96,54,3,6,'#2b6b8f'); // botella
			setPixel(97,53,'#fff5c9');
			rect(100,56,4,3,'#f0c27a'); // vaso/plato pequeño
		}

		// --- Nuevo: juguetes (juguete sencillo tipo muñeco/perro) ---
		function drawToys(){
			// juguete izquierdo (muñeco)
			setPixel(12,48,'#ff9ecb'); // cabeza
			setPixel(12,49,'#ff9ecb');
			setPixel(11,50,'#ff9ecb'); setPixel(13,50,'#ff9ecb');
			setPixel(12,51,'#0b3d6b'); // cuerpo detalle
			// juguete derecho (perrito)
			setPixel(104,48,'#ffddc4');
			setPixel(105,48,'#ffddc4');
			setPixel(103,49,'#ffddc4'); setPixel(106,49,'#ffddc4');
			setPixel(104,50,' #2f8b3e');
		}

		// --- Nuevo: guirnalda de luces / adorno en arco ---
		function drawGarlands(){
			// arco sobre el altar
			const y = 30;
			for(let x=20;x<100;x+=4){
				const col = (x % 8 === 0) ? palette.papel1 : palette.papel2;
				setPixel(x, y + Math.round(Math.sin(x/6)), col);
				setPixel(x+1, y + 1 + Math.round(Math.cos(x/5)), palette.marigold2);
			}
		}

		// --- Nuevo: más flores y caminos de cempasúchil ---
		function drawMoreFlowers(){
			const path = [[18,62],[24,60],[30,59],[36,58],[42,57],[48,56],[54,55]];
			path.forEach(([x,y])=>{
				for(let dx=-1;dx<=1;dx++){
					for(let dy=-1;dy<=1;dy++){
						if(Math.abs(dx)+Math.abs(dy)<=2){
							setPixel(x+dx,y+dy, (Math.random()<0.5)?palette.marigold1:palette.marigold2);
						}
					}
				}
			});
			// más racimos a los lados
			[[8,58],[112,58]].forEach(([x,y])=>{
				for(let i=0;i<6;i++) setPixel(x + (i%2)*2, y - i, palette.marigold1);
			});
		}

		// Limpiar y dibujar todo (actualizado para incluir nuevos elementos)
		function render(){
			ctx.clearRect(0,0,W,H);
			drawBackground();
			drawPapelPicado();
			drawGarlands();
			drawAltar();
			drawMarigolds();
			drawMoreFlowers();
			drawCandles();
			drawSkull();
			drawMoreSkulls();
			drawOfferings();
			drawFood();
			drawPhotos();
			drawToys();
			drawDetails();
		}

		// Escalado visual del canvas (mantiene la resolución lógica)
		function applyScale(s){
			canvas.style.width = (W*s) + 'px';
			canvas.style.height = (H*s) + 'px';
		}

		// Genera confetti DOM (se llama una vez) y lo deja animando vía CSS
		function createConfetti(count = 80){
			const wrap = document.getElementById('decor');
			wrap.innerHTML = '';
			for(let i=0;i<count;i++){
				const s = document.createElement('span');
				s.className = 'confetti';
				const left = Math.random()*100;
				const delay = Math.random()*-10;
				const dur = 6 + Math.random()*6;
				const size = 4 + Math.random()*6;
				const colors = [palette.papel1, palette.papel2, palette.papel3, palette.marigold1, palette.marigold2, palette.fruit1];
				s.style.left = left + '%';
				s.style.width = s.style.height = size + 'px';
				s.style.background = colors[Math.floor(Math.random()*colors.length)];
				s.style.animationDelay = delay + 's';
				s.style.animationDuration = dur + 's';
				wrap.appendChild(s);
			}
		}

		// rerender periódico para dar efecto de parpadeo en velas y pequeñas variaciones
		let _animInterval = null;
		function startAnimation(){
			if(_animInterval) clearInterval(_animInterval);
			_animInterval = setInterval(render, 220);
		}

		// UI
		const scaleInput = document.getElementById('scale');
		document.getElementById('redraw').addEventListener('click', ()=>{ render(); });
		scaleInput.addEventListener('input', (e)=> applyScale(+e.target.value));
		// generar confetti y arrancar animación
		createConfetti(80);
		applyScale(+scaleInput.value);
		render();
		startAnimation();

		// --- fin de script ---
	</script>
</body>
</html>
